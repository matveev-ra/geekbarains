package ru.homework.lesson2;

import java.util.Arrays;

public class lesson2 {

    /**
     * 1. Задать целочисленный массив, состоящий из элементов 0 и 1. Например: [ 1, 1, 0, 0, 1, 0, 1, 1,
     * 0, 0 ]. С помощью цикла и условия заменить 0 на 1, 1 на 0;
     *
     * 2. Задать пустой целочисленный массив размером 8. С помощью цикла заполнить его
     * значениями 0 3 6 9 12 15 18 21;
     *
     * 3. Задать массив [ 1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1 ] пройти по нему циклом, и числа меньшие 6
     * умножить на 2;
     *
     * 4. Создать квадратный двумерный целочисленный массив (количество строк и столбцов
     * одинаковое), и с помощью цикла(-ов) заполнить его диагональные элементы единицами;
     *
     * 5. ** Задать одномерный массив и найти в нем минимальный и максимальный элементы (без
     * помощи интернета);
     *
     * 6. ** Написать метод, в который передается не пустой одномерный целочисленный массив,
     * метод должен вернуть true, если в массиве есть место, в котором сумма левой и правой части
     * массива равны. Примеры: checkBalance([2, 2, 2, 1, 2, 2, || 10, 1]) → true, checkBalance([1, 1, 1, ||
     * 2, 1]) → true, граница показана символами ||, эти символы в массив не входят.
     * © geekbrains.ru 11
     *
     * 7. **** Написать метод, которому на вход подается одномерный массив и число n (может быть
     * положительным, или отрицательным), при этом метод должен сместить все элементы массива
     * на n позиций. Элементы смещаются циклично. Для усложнения задачи нельзя пользоваться
     * вспомогательными массивами. Примеры: [ 1, 2, 3 ] при n = 1 (на один вправо) -> [ 3, 1, 2 ]; [ 3, 5,
     * 6, 1] при n = -2 (на два влево) -> [ 6, 1, 3, 5 ]. При каком n в какую сторону сдвиг можете
     * выбирать сами.
     *
     */

    public static void main (String[] args){
        invertArray();
        fillArray();
        changeArray();
        fillDiagonal();
        minMax();

    }

    //задача1
    public static void invertArray() {
        int[] numbArr = { 1, 0, 1, 0, 0, 1 };
        for (int i = 0; i < numbArr.length; i++) {
            //numbArr[i] = numbArr[i] == 0 ? 1 : 0;//короткая запись условия
            if ( numbArr[i] == 0 ) {
                numbArr[i] = 1;
            } else  {
                numbArr[i] = 0;
            }
            //System.out.print(numbArr[i]);
        }
        System.out.println(Arrays.toString(numbArr));
    }

    //задача2
    public static void fillArray() {
        int[] numbArr = new int[8];
        for (int i = 0; i < numbArr.length; i++) {
            numbArr[i] = i*3;
        }
        System.out.println(Arrays.toString(numbArr));
    }

    //задача3
    public static void changeArray() {
        int[] numbArr = { 1, 5, 3, 2, 11, 4, 5, 2, 4, 8, 9, 1 };
        for (int i = 0; i < numbArr.length; i++) {
            if ( numbArr[i] < 6 ) {
                numbArr[i] = numbArr[i]*2;
            }
        }
        System.out.println(Arrays.toString(numbArr));
    }

    //задача4
    public static void fillDiagonal() {
        int[][] arr = new int[4][4];

        for (int x = 0; x < 4; x++){
            for(int y = 0; y < 4; y++){
                if ( x == y){
                    arr[x][y] = 1;
                }
                arr[x][arr.length - x - 1] = 1;
                System.out.printf("%d ", arr[x][y]);

            }
            System.out.println();
        }
    }

    /**
     * По 5 задаче, вспоминаем, на семинаре мы разбирали подобную
     * задачу на примере двумерного массива, а тут у нас задание еще проще,
     * мы работаем с одномерным массивом, значит, просто должны пройтись
     * по всем его элементам и сохранять элементы, значения которых будут
     * максимальны или минимальны при сравнении с другими элементами:
     */
    //задача5
    public static void minMax() {
        int [] mass5 = { 4, 5, 2, -7, -120, 456, 3000};
        int minN = 0; //для определения индекса минимального значения
        int min = mass5[minN];
        int maxN = 0; //для определения индекса максимального значения
        int max = mass5[maxN];
        for (int i = 0 ; i < mass5.length; i++) {
            if (mass5[i] < min) {
                min = mass5[i];
                minN = i;
            }
            if (mass5[i] > max) {
                max = mass5[i];
                maxN = i;
            }
        }
        //Вывожу именно индекс элемента, а непорядковый номер
        System.out.printf("Минимальный элемент имеет индекс [%d] и равен %d\n", minN, min);
        //Вывожу именно индекс элемента, а непорядковый номер
        System.out.printf("Максимальный элемент имеет индекс [%d] и равен %d\n", maxN, max);


    }

    //задача6
    static boolean checkBalance(int[] arr) {
        int sum = 0;

        // Для начала мы проходимся по всем элементам массива, посчитаем сумму всех его элементов
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
        }

        // Посчитали и запомнили в переменную sum

        // Далее, мы должны понять, кратна ли сумма 2? Т е является ли сумма четной ? Если нет, мы явно можем сказать,
        // что никогда не поделим все элементы поровну, поэтому, если сумма не кратна двум, сразу возвращаем false и завершаем работу метода:
        if (sum % 2 != 0) return false;

        // Если сумма кратна двум, попытаемся найти "баланс" между правой и левой частью:

        // Например у нас есть массив из чисел 2 2 2 6
        // Для начала, мы условно сумму значений массива (12) делим на 2, получим 6.
        // Далее вводим новую переменную и присваиваем 0 (int left = 0;)

        // Далее в цикле идем по всем элементам массива и складываем их значения в переменную left, параллельно сравнивая сумму с нашим числом 6, ответ будет такой:

        // Если в процессе сложения значения элементов мы получим сумму 6, мы можем сказать, что нашли баланс, если в некоторый момент, после сложения чисел, число будет больше 6, значит мы баланс никогда не найдем:
        sum /= 2;
        int left = 0;

        for (int i : arr) {
            left += i;
            if (left == sum) return true;
            if (left > sum) return false;
        }

        return false;
    }

    /**
     * По задаче 7:
     *
     * основная идея следующая:
     * Допустим, наш массив состоит из 9 элементов:
     *
     * int[] someArr = {2, 3, 4, 1, 8, 14, 5, 10, 13};
     * И мы хотим сместить элементы на 2 или на 3, может на -4,
     * а может и на 240, на -1450, тогда мы действительно можем убрать
     * подобную проверку, пройтись в ОСНОВНОМ цикле
     * 1450 раз и мы действительно получим валидный результат.
     *
     * При этом мы понимаем, что наша работа будет бесполезна,
     * когда число, на которое мы производим смещение кратно самой
     * размерности массива, мы просто впустую прогоняем циклы.
     *
     * Допустим, я предлагаю вам сместить элементы на 9, в таком случае,
     * вы вообще ничего не должны делать, все ваши элементы, по итогу смещений, останутся на прежних местах.
     *
     * Далее, допустим я хочу произвести смещение на 10, следуем нашей формуле:
     *
     * 10 % 9 = 1;
     * 9 + 1 = 10;
     * 10 % 9 = 1;
     * Итого: Необходимо сместить элементы всего на 1,
     *
     * Допустим я хочу произвести смещение на - 10, вычисляем:
     *
     * -10 % 9 = -1
     * 9 - 1 = 8;
     * 8 % 9 = 8
     * Итого: Необходимо произвести 8 итераций основноцикла, против 10 итераций (-10)
     *
     * Ну и частный случай, 0, тогда ответ - 0.
     */
    //задача7
    static void shift(int[] arr, int n) {
        int shift = (arr.length + n % arr.length) % arr.length; // Вычисляем реальное смещение
        for (int i = 0; i < shift; i++) { // Выполним цикл смещения по одному элементу в соответствии с значенимем реального смещения (переменная shift)
            int temp = arr[arr.length - 1]; // Сохраняем значение ПОСЛЕДНЕГО элемента массива
            for (int j = arr.length - 1; j > 0 ; j--) { // Пройдем по всем элементам массива с конца в начало, заменим значение текущего элемента массива значением элемента, предшествующего текущему
                arr[j] = arr[j - 1];
            }
            arr[0] = temp; // А как быть с самым первым элементом? Вот как раз из переменной temp мы и получим недостающее значение
        }
    }
}
